import { HeuristicResult } from "@shared/schema";
import { analyzeIP } from "../analyzers/ip";
import { analyzeDomain } from "../analyzers/domain";
import { analyzeURL } from "../analyzers/url";
import { applyCorrelations } from "../risk/correlation";
import { sanitizeInput } from "./sanitization";
import { analyzeObfuscation } from "./obfuscation";
import { analyzeIDNDomain } from "./idn";
import { analyzeURLPath } from "./path-analysis";
import { analyzePort } from "./port-analysis";
import { analyzeDomainReputation } from "./domain-reputation";
import { analyzeRedirects } from "./redirect-analysis";
import { analyzeMobileThreats } from "./mobile-threats";
import { reputationService } from "./reputation";
import { analyzeHomoglyphs } from "./homoglyph";
import { osintService } from "./osint-engine";
import { archiveService } from "./archive-intel";
import {
  lookupWhoisData,
  runDetectionEngines,
  checkURLReputation,
  type WhoisData,
  type DetectionEngineResult,
} from "./threat-intelligence";

export type InputType = "ip" | "domain" | "url";

/**
 * Stage 1: Pre-processing & Sanitization
 */
function preprocess(input: string) {
  const sanitization = sanitizeInput(input);
  const obfuscation = analyzeObfuscation(sanitization.sanitized);
  const analyzedInput = obfuscation.obfuscationLevel === "high" ? obfuscation.decodedContent : sanitization.sanitized;

  return {
    analyzedInput,
    heuristics: [...sanitization.heuristics, ...obfuscation.heuristics]
  };
}

/**
 * Stage 2: Intelligence Gathering (Parallel OSINT v2)
 */
async function gatherIntelligence(type: InputType, target: string) {
  const intel: any = {
    ipReputation: null,
    abuseIPDB: null,
    ipLocation: null,
    whoisData: null,
    virusTotal: null,
    urlScan: null,
    archiveHistory: null,
    detectionEngines: [],
    urlIntelligence: []
  };

  const tasks: Promise<void>[] = [];

  if (type === "ip") {
    tasks.push(osintService.getAbuseIPDB(target).then(res => { intel.abuseIPDB = res; }));
    tasks.push(osintService.getVirusTotal(target, "ip").then(res => { intel.virusTotal = res; }));
    tasks.push(osintService.getIPLocation(target).then(res => { intel.ipLocation = res; }));
    tasks.push(runDetectionEngines(target).then(res => { intel.detectionEngines = res; }));
  } else if (type === "domain" || type === "url") {
    const hostname = type === "url" ? new URL(target.startsWith('http') ? target : `https://${target}`).hostname : target;

    tasks.push(lookupWhoisData(hostname).then(res => { intel.whoisData = res; }));
    tasks.push(osintService.getVirusTotal(hostname, type === "url" ? "url" : "domain").then(res => { intel.virusTotal = res; }));
    tasks.push(checkURLReputation(hostname).then(res => { intel.urlIntelligence = res; }));
    tasks.push(runDetectionEngines(hostname).then(res => { intel.detectionEngines = res; }));
    tasks.push(archiveService.getHistory(hostname).then(res => { intel.archiveHistory = res; }));
    
    if (type === "url") {
      tasks.push(osintService.getURLScan(target).then(res => { intel.urlScan = res; }));
    }
  }

  // Optimized timeout: 10s for deep OSINT
  await Promise.race([
    Promise.allSettled(tasks),
    new Promise(resolve => setTimeout(resolve, 10000))
  ]);

  return intel;
}

/**
 * Main Analysis Pipeline
 */
export async function analyzeInput(type: InputType, input: string) {
  const startAt = Date.now();
  console.log(`[analyzeInput] Pipeline started for ${type}: ${input}`);

  // 1. Preprocess
  const { analyzedInput, heuristics: baseHeuristics } = preprocess(input);
  const evidence: HeuristicResult[] = [...baseHeuristics];

  // 2. Intelligence Gathering
  const intel = await gatherIntelligence(type, analyzedInput);

  // 3. Execution
  let score = evidence.reduce((sum, h) => sum + h.scoreImpact, 0);

  if (type === "ip") {
    const r = await analyzeIP(analyzedInput);
    score += r.score;
    evidence.push(...r.heuristics);

    if (intel.ipReputation?.abuseConfidenceScore > 25) {
      const impact = Math.floor(intel.ipReputation.abuseConfidenceScore / 2);
      score += impact;
      evidence.push({
        name: "IP Reputation Score",
        status: intel.ipReputation.abuseConfidenceScore > 75 ? "fail" : "warn",
        description: `IP has abuse confidence score of ${intel.ipReputation.abuseConfidenceScore}%`,
        scoreImpact: impact,
      });
    }
  }

  if (type === "domain" || type === "url") {
    const targetHostname = type === "url" ? new URL(analyzedInput.startsWith('http') ? analyzedInput : `https://${analyzedInput}`).hostname : analyzedInput;

    // Core Domain Heuristics
    evidence.push(...analyzeIDNDomain(targetHostname).heuristics);
    evidence.push(...analyzeDomainReputation(targetHostname).heuristics);

    // Reputation & Homoglyph (The "Perfected" logic)
    const repSignal = reputationService.getReputationSignal(targetHostname);
    if (repSignal) {
      evidence.push(repSignal);
      score += repSignal.scoreImpact;
    }

    const homoglyphSignal = analyzeHomoglyphs(targetHostname);
    if (homoglyphSignal && !repSignal) {
      evidence.push(homoglyphSignal);
      score += homoglyphSignal.scoreImpact;
    }

    const domainR = await analyzeDomain(targetHostname);
    score += domainR.score;
    evidence.push(...domainR.heuristics);

    if (intel.whoisData) {
      if (intel.whoisData.age < 30) {
        score += 35;
        evidence.push({ name: "Very New Domain", status: "fail", description: `Registered ${intel.whoisData.age} days ago`, scoreImpact: 35 });
      }
    }

    // ðŸ”¥ Wayback Machine Archive Analysis
    const archiveSignal = await archiveService.getMaturitySignal(targetHostname);
    if (archiveSignal) {
      evidence.push(archiveSignal);
      score += archiveSignal.scoreImpact;
    }
  }

  if (type === "url") {
    const urlObj = new URL(analyzedInput.startsWith('http') ? analyzedInput : `https://${analyzedInput}`);
    score += (await analyzeURL(analyzedInput)).score;
    evidence.push(...analyzeURLPath(urlObj.pathname, urlObj.search).heuristics);
    evidence.push(...analyzePort(urlObj).heuristics);
    evidence.push(...analyzeRedirects(urlObj).heuristics);
    evidence.push(...analyzeMobileThreats(urlObj).heuristics);
  }

  // 4. Scoring & Final Verdict
  const { newEvidence, scoreBoost } = applyCorrelations(evidence, { input, type });
  score = Math.min(100, Math.max(0, score + scoreBoost));

  let riskLevel = "Safe";
  if (score >= 70) riskLevel = "Malicious";
  else if (score >= 30) riskLevel = "Suspicious";

  const finalEvidence = newEvidence.map(e => ({ ...e, status: e.status as "pass" | "warn" | "fail" }));

  console.log(`[analyzeInput] Pipeline complete in ${Date.now() - startAt}ms. Score: ${score}`);

  const confidence = Math.round((finalEvidence.filter(e => e.status !== "pass").length / Math.max(finalEvidence.length, 1)) * 100);

  return {
    riskScore: score,
    riskLevel,
    confidence,
    evidence: finalEvidence,
    details: {
      engine: "ThreatAnalyzer",
      engineVersion: "2.1.0-optimized",
      confidence,
      evidence: finalEvidence, // Matches required field
      heuristics: finalEvidence, // Optional field
      threatIntelligence: intel,
      metadata: {
        inputType: type,
        sanitizedInput: input,
        hasCorrelations: true,
        processingTimeMs: Date.now() - startAt
      }
    },
    summary: `Analysis complete. Verdict: ${riskLevel}`
  };
}
